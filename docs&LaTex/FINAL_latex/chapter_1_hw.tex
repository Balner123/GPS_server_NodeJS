\chapter{Fyzické zařízení - tracker}
\label{chap:hw_tracker}

\section{Úvod a koncepce}
Tracker je základní součást systému, vše ostatní se zrodilo z jeho potřeb o rozšíření, proto je to hlavní část projektu. Jeho hlavním úkolem je pravidelně zaznamenávat polohu a odesílat ji na server, dle požadavků a jednotlivých nastavení uživatelem. 
Hlavními (základními) požadavky na zařízení jsou:

\begin{itemize}
    \setlength\itemsep{0.2em}
    \setlength\parskip{0pt}
    \setlength\parsep{0pt}
    \item Pravidelný zisk polohy (GPS fix)
    \item Pravidelné odesílání dat na Server        
    \item Nízká spotřeba energie (pro dlouhou výdrž na baterii)
\end{itemize}

\noindent To jsou však pouze základní požadavky, se kterými návrh začínal. Postupem času se poté rozvinul v mnohem komplexnější systém chování (např. cachovaní, Deep Sleep).
Zde přikládám diagram použití pro finální konfiguraci zařízení.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{../docs_hw/schemas/use_case_dia.png} 
    \caption{Usecase diagram}
    \label{fig:use_case_dia}
\end{figure}

\section{POUŽITÉ TECHNOLOGIE}
\label{sec:hw_teorie}

\subsection{Mikrokontroléry (ESP32)}
Jako řídící jednotka byl zvolen čip \textbf{ESP32} od společnosti Espressif Systems. Jedná se o 32-bitový mikrokontrolér (architektura Xtensa LX6) s integrovanou Wi-Fi a Bluetooth konektivitou. 
Pro tento projekt je klíčová jeho pokročilá správa napájení, konkrétně režim \textit{Deep Sleep} viz \ref{sec:deep_sleep}.

\subsection{Mobilní komunikace a AT příkazy}
Pro přenos dat využíváme síť LTE (4G). Komunikace mezi mikrokontrolérem a modemem probíhá po sériové lince (UART) pomocí standardizované sady \textbf{AT příkazů} (Hayes command set).

\subsection{Globální navigační systémy (GPS)}
Pro získávání polohy je využit systém GPS. Modul komunikuje s mikrokontrolérem pomocí textového protokolu \textbf{NMEA}. 
Z celého proudu dat jsou parsovány především věty \texttt{\$GPRMC} (Recommended Minimum Specific GPS/TRANSIT Data), 
které obsahují klíčové údaje o poloze, času a rychlosti.

\subsection{Operační systémy reálného času (FreeRTOS)}
Pro zajištění deterministického chování a správy souběžných procesů (komunikace, sběr dat) je využit operační systém reálného času \textbf{FreeRTOS}. 
Ten umožňuje rozdělit aplikaci do samostatných úloh (Tasks) s definovanou prioritou, které jsou spravovány plánovačem.

\subsection{Souborový systém LittleFS}
Pro ukládání konfigurace a offline dat (cache) je využit souborový systém \textbf{LittleFS}. 
Byl zvolen pro svou odolnost vůči výpadkům napájení (power-loss resilience), což je u bateriového zařízení kritické. 
Díky mechanismu \textit{Copy-on-Write} nedochází k poškození souborového systému ani při náhlém vypnutí.

\section{Návrh hardware - Výběr komponent}
\label{sec:hw_navrh}

Návrh hardwarové části systému vychází z požadavku na vytvoření nezávislého zařízení schopného provozu na baterii. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{image/T-Call-A7670-3936760664.jpg} 
    \caption{LilyGO T-Call V1.5 - integrované řešení ESP32 + LTE modem + použité piny}
    \label{fig:LilyGO_T-Call}
\end{figure}

\subsection{LilyGO T-Call v1.5}
Základem celého zařízení je vývojová deska \textbf{LilyGO T-Call} (verze V1.5), která v sobě integruje výkonný mikrokontrolér ESP32 a komunikační modem. Tato volba byla učiněna kvůli následujících kritérií:
\begin{itemize}
    \item \textbf{Integrace:} Spojení MCU a modemu na jedné desce eliminuje nutnost složitého propojování (bylo možné použít oddělenou desku ESP32 a modem SIM800L, avšak zde by vznikly problémy s napájením. Modem totiž ve špičkách odebírá až 2A.)
    \item \textbf{Konektivita:} Použitý modem SIMCOM A7670 podporuje moderní sítě LTE (4G), což zajišťuje lepší pokrytí a nižší latenci než zastaralé 2G moduly (např. SIM800L).
\end{itemize}

V rané fázi projektu bylo zkoušeno používat desku LilyGO SIM800L (s podporou pouze 2G sítí), avšak kvůli vzniklému zkratu (typická to chyba) a nemožnosti opravy desky ručně (bylo by potřeba mikropájení), přešli jsme na desku T-call v1.5 s modemem A7670 (podpora LTE sítí).

\subsection{ Multi-GNSS L76K modul}

Pro získávání polohy byl zvolen externí modul \textbf{Multi-GNSS L76K} (hlavně kvůli dostupnosti).
Deska LilyGo T-call sice disponuje možností zisku GPS přes vestavěný modem, avšak externí modul nabízí lepší citlivost a
rychlost zisku dat (dle testů až 4x rychleji), také to, že takový modul byl ve vlastnictví již před zahájením vývoje projektu, a 
tudíž nebylo nutné jej dokupovat prosadilo jeho použití. 

\begin{figure}[h]
	\centering
	\begin{subfigure}{0.35\linewidth}
		\centering
		\includegraphics[width=\linewidth]{image/multignsslk76.jpg}
		\caption{Externí modul Multi-GNSS L76K}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\linewidth}
		\centering
		\includegraphics[width=\linewidth]{../docs_hw/schemas/NPN_control.png}
		\caption{Ovladání GND}
	\end{subfigure}
	\caption{Modul GPS a zapojení pro řízení napájení}
	\label{fig:gps_module}
\end{figure}

Kvůli lepším možnostem ovládání spotřeby je modul GPS připojen přes tranzistorový spínač (NPN), který umožňuje mikrokontroléru zcela odpojit napájení GPS modulu, když není potřebný v zapnutém stavu.
Aplikován je princip řízeného GND, sice bylo rozvažováno nad stabilnější možností ovládat VCC (takto se může v krajních případech dostat do modulu napětí), 
avšak z důvodu absence vhodného PNP tranzistoru bylo zvoleno toto řešení.

\subsection{Baterie, TP4056 + MT3608}

Napájení zajišťuje Li-Ion článek typu 18650 (kapacita 3200 mAh zvolena kvůli ceně), který je dobíjen pomocí modulu s čipem \textbf{TP4056}. Pro zvýšení napětí z baterie (3.7V) na úroveň potřebnou pro stabilní provoz desky a GPS modulu (5 V) je použit DC-DC step-up měnič \textbf{MT3608}.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../docs_hw/screenshots/battery_carige.jpg}
        \caption{TP4056 + MT3608 v pouzdře}
        \label{fig:battery_charging_module_a}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\linewidth}
        \centering
        \includegraphics[width=\linewidth]{../docs_hw/screenshots/Power_desk.jpg}
        \caption{Osazená deska - Power Latch modul}
        \label{fig:battery_charging_module_b}
    \end{subfigure}
    \caption{Baterie a nabíjecí modul / power latch modul - osazená deska}
    \label{fig:battery_charging_module}
\end{figure}


\subsection{Řízení napájení - Power Latch modul}
V případě zařízení jakým je tracker, nestačí pouhé "tvrdé" odpojení od baterie vypínačem. Systém potřebuje čas na bezpečné ukončení procesů (uzavření souborů, odhlášení ze sítě).
K tomuto účelu slouží obvod \textbf{Power Latch} (samodržný obvod). Jeho primárním cílem je umožnit mikrokontroléru převzít kontrolu nad vlastním napájením.
Navržen byl dle rady a schématu od známého v oboru Elektroniky. Deska byla navržena v EasyEDA a vyrobena přes službu JLCPCB. Pro úsporu peněz byla osazena součástkami ručně (cena osazení cca. 4x převyšovala cenu součástek). Proto byly součástky vybrány dle požadavků na možnost ručního osazení (např. místo SMD vybrán mosfet v pouzdře TO-220 atd.).

Viz implementace ve firmware, sekce \ref{subsec:napajeni_hw}.
\begin{figure}[H]
    \centering
		\includegraphics[width=0.7\linewidth]{../docs_hw/schemas/schema_POWER_modu_cuttedl.jpg}
		\caption{Schéma power-modul [easyEDA]}
        \label{fig:hw_schema_power}
\end{figure}

\clearpage
\section*{Výsledná sestava - schéma zapojení - piny}

\noindent GPIO piny byly přiřazeny dle dostupnosti na desce.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{../docs_hw/schemas/schema_GENERAL_vyrez.jpg} 
    \caption{Blokové schéma zapojení hardwarového trackeru [easyEDA]}
    \label{fig:hw_schema_general}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{../docs_hw/screenshots/foto_progresACTUAL.jpg} 
    \caption{"vnitřnosti" zařízení}
    \label{fig:class_dia}
\end{figure}

\section*{Seznam použitých součástek}
\begin{itemize}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
  \item LilyGO T-Call V1.5 (ESP32 + LTE modem A7670)
  \item Externí GPS modul Multi-GNSS L76K (alternativně NEO-6M)
  \item LTE mikroSIM karta, datový tarif (díky minimálnímu toku dat bylo za celé období testování využito do 1MB dat)
  \item GPS anténa (u.FL/SMA dle modulu)
  \item LTE anténa (u.FL/SMA dle desky)
  
  \item Li-Ion 18650 článek
  \item Nabíjecí modul TP4056 + Step-up měnič MT3608

  \item SEMTECH BC337-25 bipolární NPN tranzistor
  \item INFINEON IRF4905PBF P-Channel MOSFET
  \item Rezistory (1 k$\Omega$, 330 $\Omega$, 100 k$\Omega$)
  \item KLS 7-P8.0x8.0-0 non lock tlačítko do DPS, 2 póly, ON-(ON) 
  \item LED dioda 3mm zelená
\end{itemize}

\section*{Návrh \uv{krabice} zařízení - model}
    
\noindent V počátcích vývoje byl vytvořen návrh možného obalu pro komponenty zařízení, avšak s tím jak byla přehodnocována struktura zapojení a vyběr použitých součástek, tak model nestíhal držet krok. 
Při testovacím tisku a složení prototypu modelu také bylo zjištěno, že "Cable managment problem" si vyžaduje mnohem více pozornosti než bylo předvídáno. Model sice byl navržen kompaktně, ale v určitých případech až přespříliš, kdy nebylo možné nějakým postupem součásti v krabičce uzavřít bez násilných úprav. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.40\linewidth]{../docs_hw/screenshots/box_prototyp.png} 
    \caption{prototyp krabičky - průhled}
    \label{fig:box_prototyp}
\end{figure}

\clearpage

\section{Implementace firmware}
\label{sec:fw_implementace}

Software pro mikrokontrolér byl vyvíjen v jazyce C++ s využitím frameworku Arduino. Jako vývojové prostředí bylo zvoleno \textbf{Visual Studio Code} s rozšířením \textbf{PlatformIO} kvůli největší známosti.
\subsection{Architektura a použité knihovny}
Projekt je koncipován modulárně, což usnadňuje orientaci v kódu a případné budoucí rozšiřování. 
Zdrojový kód je rozdělen do samostatných jednotek (hlavičkové a zdrojové soubory) podle funkčních celků:

\begin{itemize}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item \texttt{main.cpp}: Hlavní smyčka programu, řízení stavového automatu.
    \item \texttt{gps\_control}: Obsluha GPS modulu, parsování NMEA zpráv, řízení napájení GPS.
    \item \texttt{modem\_control}: Komunikace s LTE modemem přes AT příkazy, správa GPRS připojení a HTTP požadavků.
    \item \texttt{file\_system}: Abstrakce nad souborovým systémem LittleFS, ukládání a načítání konfigurace a offline dat.
    \item \texttt{power\_management}: Řízení spotřeby, ovládání Power Latch obvodu, přechod do Deep Sleep.
    \item \texttt{ota\_mode}: Implementace servisního režimu, webového serveru a OTA aktualizací.
\end{itemize}

Mezi klíčové knihovny třetích stran, na kterých je firmware postaven, patří:
\begin{itemize}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item \textbf{TinyGSM:} Univerzální knihovna pro komunikaci s GSM/LTE modemy. Pro tento projekt byl použit profil \texttt{TINY\_GSM\_MODEM\_A7670}.
    \item \textbf{TinyGPS++:} Efektivní parser dat z GPS modulu.
    \item \textbf{ArduinoJson:} Knihovna pro serializaci a deserializaci JSON objektů, používaná pro komunikaci s API serveru.
    \item \textbf{DeepSleep.h:} Umožňuje použití "hlubokého spánku" v ESP32
    \item \textbf{Wifi.h:} knihovna pro připojení k WiFi síti, použitá v OTA režimu
    \item \textbf{FreeRTOS , LittleFS:} již zmíněny v sekci \ref{sec:hw_teorie}
\end{itemize}

\clearpage

\subsection{Pracovní cyklus}

Kvůli potřebě minimalizovat spotřebu baterie používá firmware funkcionalitu ESP32 : \textbf{DeepSleep} (hluboký spánek). viz \ref{sec:deep_sleep}.
Protože je použita tato funkcionalita, veškeré činnosti zařízení se odehrávají v \textbf{\texttt{setup()}}.
Funkce \textbf{\texttt{loop()}}, obyčejně užita pro hlavní program, je nevyužita.
Veškerý kód je proto umístěn ve funkci \textbf{\texttt{setup()}}.

\noindent Standardní pracovní cyklus probíhá v následujících krocích:

\begin{enumerate}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item \textbf{Probuzení a inicializace:} Po přivedení napájení (tlačítkem nebo časovačem) se provede inicializace periferií a načtení konfigurace ze souborového systému.
    \item \textbf{Získání polohy (GPS Fix):} Zapne se GPS modul. Mikrokontrolér čeká na platná data o poloze. Pokud není fix získán do stanoveného limitu (timeout), pokus se ukončí.
    \item \textbf{Uložení dat:} Získaná data (nebo informace o chybě) jsou uložena do interní paměti (LittleFS).
    \item \textbf{Odeslání dat (Upload):} Aktivuje se modem. Zařízení se připojí k mobilní síti a pokusí se odeslat dávku uložených záznamů na server.
    \item \textbf{Synchronizace:} Server potvrdí přijetí dat a případně pošle novou konfiguraci (např. změnu intervalu sledování).
    \item \textbf{Uspání (Deep Sleep):} Po dokončení všech úloh se zařízení odpojí od sítě, vypne periferie a přejde do režimu hlubokého spánku na dobu definovanou v konfiguraci.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{../docs_hw/schemas/life_cycle_sequence_dia.png} 
    \caption{sekvenční diagram životního cyklu}
    \label{fig:life_cycle_sequence_dia}
\end{figure}

\subsection{Paralelní zpracování a obsluha přerušení (FreeRTOS)}
Vzhledem k tomu, že ESP32 disponuje dvěma jádry používáme na něm operační systém FreeRTOS, který umožňuje efektivně rozdělit úlohy. 
V našem případě používáme FreeRTOS pro obsluhu funkce vypnutí zařízení. Nemohli jsme použít pouze attachInterrupt (ISR)
jelikož při přerušení nelze provádět složité akce, dlouhé I/O operace nebo vyvolávat delay.

FreeRTOS zde řeší problém souběžnosti (\uv{Concurrency}):
\begin{itemize} 
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item Když zmáčknete tlačítko, ISR se provede bleskově a jen \uv{probudí} ShutdownTask.
   \item Tento task běží \uv{na pozadí} a může bezpečně provádět pomalé operace (uspání modemu, uložení dat), aniž by zablokoval celý systém v kritickém stavu ISR.
\end{itemize}

Následující ukázka z \texttt{power\_management.cpp} ukazuje inicializaci této logiky. 
Funkce \\ \texttt{xTaskCreatePinnedToCore} vytvoří novou úlohu \texttt{ShutdownTask}, která běží na pozadí a čeká na signál z přerušení tlačítka.

\clearpage
\begin{minted}{cpp}
    void power_init() {
  if (shutdownTaskHandle != nullptr) {return;} // Already initialized
  pinMode(PIN_BTN, INPUT_PULLUP); // Use internal pull-up
  // Create the FreeRTOS task for button handling
  xTaskCreatePinnedToCore(
    ShutdownTask,     // Task function
    "ShutdownTask",   // Name of task
    4096,             // Stack size (bytes)
    NULL,             // Parameter to pass to function
    configMAX_PRIORITIES - 1, // Task priority (highest)
    &shutdownTaskHandle, // Task handle
    0                 // Core where the task should run (Core 0)
  );
  // Attach interrupt to the button pin
  attachInterrupt(digitalPinToInterrupt(PIN_BTN), on_button_isr, FALLING);
  DBG_PRINTLN(F("[POWER] Button interrupt and shutdown task initialized."));
}
\end{minted}

\subsection{Řízení napájení a Power Latch modul}
\label{subsec:napajeni_hw}
Princip celého systému napájení je následující:
\begin{enumerate}
    \setlength\itemsep{0.2em}
    \setlength\parskip{0pt}
    \setlength\parsep{0pt}
    \item Uživatel stiskne tlačítko, čímž přivede napětí do systému.
    \item ESP32 se nastartuje a okamžitě nastaví pin \texttt{PIN\_EN} na úroveň HIGH. Tím "přemostí" tlačítko a drží se pod napětím i po jeho uvolnění.
    \item Když chce zařízení přejít do vypnutého stavu (Deep Sleep nebo úplné vypnutí), provede potřebné úkony a následně nastaví \texttt{PIN\_EN} na LOW, čímž se samo odpojí.
\end{enumerate}

Následující ukázka kódu demonstruje funkci \texttt{graceful\_shutdown()}, která zajišťuje bezpečné vypnutí.

\begin{minted}{cpp}
void graceful_shutdown() {
  DBG_PRINTLN(F("\n[POWER] Shutdown requested - starting graceful power-off..."));
  // Detach interrupt to prevent any further triggers during shutdown
  detachInterrupt(digitalPinToInterrupt(PIN_BTN));
  g_shutdown_requested = true;
  power_status_mark_off();
  status_led_set(false);
  // Ask long-running tasks to abort before we tear down shared resources
  gps_request_abort();
  modem_disconnect_gprs(); modem_power_off(); // powering down modem...
  // Wait briefly for GPS loops to notice the abort request
  for (int i = 0; i < 50 && gps_is_active(); ++i) {
    vTaskDelay(pdMS_TO_TICKS(10));
  }
  gps_close_serial(); gps_power_down(); fs_end(); // ending other modules...
  // Finally, cut power to the ESP32
  digitalWrite(PIN_EN, LOW);
}
\end{minted}

\subsubsection{Režim hlubokého spánku (Deep Sleep)}
\label{sec:deep_sleep}
Kromě úplného vypnutí (Power Off) využívá zařízení také režim hlubokého spánku. Tento režim používáme pro cyklické probouzení trackeru (jinak by bylo nutné pokaždé stisknout tlačítko pro zapnutí, což je očividně nepoužitelné).
V režimu Deep Sleep je vypnuto CPU, RAM i většina periferií. Napájen zůstává pouze RTC (Real Time Clock) řadič a malá část paměti (RTC Slow Memory). Spotřeba čipu v tomto stavu klesá na jednotky mikroampérů.

Probuzení z tohoto režimu může nastat dvěma způsoby:
\begin{enumerate}
    \setlength\itemsep{0.2em}
    \setlength\parskip{0pt}
    \setlength\parsep{0pt}
    \item \textbf{Časovač (Timer Wakeup):} Po uplynutí nastaveného intervalu (např. 10 minut).
    \item \textbf{Externí signál (Ext0 Wakeup):} Stiskem tlačítka (změna logické úrovně na pinu GPIO32).
\end{enumerate}

Následující funkce \texttt{enter\_deep\_sleep} ukazuje konfiguraci těchto budících zdrojů před uspáním procesoru.

\begin{minted}{cpp} 
void enter_deep_sleep(uint64_t seconds) {
  DBG_PRINT(F("[SLEEP] Entering deep sleep"));
  // Detach interrupt before sleeping to prevent issues on wake
  detachInterrupt(digitalPinToInterrupt(PIN_BTN));
  // Enable wakeup by timer
  esp_sleep_enable_timer_wakeup(seconds * 1000000ULL); // microseconds
  // Enable wakeup by button (on LOW level)
  esp_sleep_enable_ext0_wakeup(static_cast<gpio_num_t>(PIN_BTN), 0);
  esp_deep_sleep_start();}
\end{minted}

\subsection{Zpracování GPS dat a parsování NMEA}
Komunikace s GPS modulem L76K probíhá přes hardwarovou sériovou linku (UART1). Modul v pravidelných intervalech (1 Hz dle dokumentace) odesílá textová data ve formátu NMEA. Pro zpracování těchto dat do rozumné podoby jsme využili knihovnu \textbf{TinyGPS++}.

Klíčovou částí implementace je funkce \texttt{gps\_get\_fix}, která v cyklu čte znaky ze sériového portu a předává je parseru pomocí metody \texttt{gps.encode()}. Jakmile parser detekuje platnou větu a aktualizuje souřadnice, zkontroluje se, zda jsou splněny podmínky pro platný fix (validní poloha, čas a minimální počet satelitů).
Viz. \texttt{gps\_control.cpp}.

\subsection{Správa datového úložiště (LittleFS)}
Jedním z klíčových požadavků byla schopnost pracovat i v oblastech bez signálu mobilní sítě nebo v případech výpadku připojení nebo selhání modemu. Firmware proto implementuje cachování dat.
Naměřené polohy nejsou odesílány okamžitě, ale jsou nejprve serializovány a uloženy do souboru \texttt{/gps\_cache.log} v paměti flash (LittleFS). Pro tento účel musel být systém inicializován pomocí vytvoření složky \textbf{data/} ve složce firmwaru.
Při každém úspěšném připojení k internetu se pak zařízení pokusí odeslat dávku nejstarších záznamů (pravidlo : FIFO - First In, First Out). Teprve po potvrzení serverem (success: true) jsou zaznamy z cache smazány.

\noindent   Následuje příklad funkce \texttt{fs\_init()} jež zajišťuje nabootovaní souborového systému.

\begin{minted}{cpp}
bool fs_init() {
  FsLockGuard lock;
  if (!lock.isLocked()) {
    DBG_PRINTLN(F("[FS] Failed to acquire FS lock during init."));
    return false;
  }
  if (!LittleFS.begin()) {
    DBG_PRINTLN(F("[FS] An Error has occurred while mounting LittleFS"));
    return false;
  }
  DBG_PRINTLN(F("[FS] LittleFS mounted successfully."));
  preferences.begin(PREFERENCES_NAMESPACE, false); // false for read/write
  DBG_PRINTLN(F("[FS] Preferences initialized."));
  return true;
}
\end{minted}

\section{Komunikace a data}
\label{sec:hw_komunikace}

\subsection{Komunikační protokol a zabezpečení}
Komunikace mezi zařízením a serverem probíhá přes protokol HTTPS (modem SIMCOM A7670 umožňuje použití šifrování narozdíl třeba od SIM800L).

Pro navázání zabezpečeného spojení využívá modem knihovnu SSL/TLS. 
Zásadnější ovšem je samotné připojení zařízení k GPRS síti, které je zabezpečeno pomocí "APN credentials" poskytovatele mobilních služeb.

\begin{minted}{cpp}
bool connectGPRS() {
  SerialMon.print(F("Waiting for network..."));
  if (!modem.waitForNetwork(240000L, true)) { 
    SerialMon.println(F(" fail"));
    return false;
  }
  SerialMon.println(F(" success"));

  SerialMon.print(F("Connecting to GPRS: ")); SerialMon.print(apn);
  if (!modem.gprsConnect(apn.c_str(), gprsUser.c_str(), gprsPass.c_str())) {
    SerialMon.println(F(" fail"));
    return false;
  }
  SerialMon.println(F(" success"));
  SerialMon.print(F("GPRS IP: ")); SerialMon.println(modem.getLocalIP());
  return true;
}
\end{minted}



\subsection{Struktura dat a handshake}
Komunikace se serverem probíhá prostřednictvím REST API rozhraní. Zařízení odesílá data ve formátu JSON (JavaScript Object Notation).

\noindent Detailní specifikace jednotlivých endpointů, struktura přenášených zpráv a návratové kódy jsou podrobně popsány v kapitole věnované serverové části (viz sekce \ref{sec:server_api}).

Pro operace a práci s odesílanými a přijímanými JSON daty je využita knihovna \textbf{ArduinoJson}. Následující ukázka kódu z funkce \texttt{modem\_perform\_handshake} demonstruje sestavení JSON objektu pro úvodní "pozdrav" (handshake) a zpracování odpovědi.

\begin{minted}{cpp}
bool modem_perform_handshake() {
  JsonDocument payloadDoc;
  payloadDoc["device_id"] = deviceID;
  payloadDoc["client_type"] = CLIENT_TYPE;
  payloadDoc["power_status"] = power_status_to_string(power_status_get());
  String payload;
  serializeJson(payloadDoc, payload);

  DBG_PRINTLN(F("[MODEM] Performing device handshake..."));
  int statusCode = 0;
  String response = modem_send_post_request(RESOURCE_HANDSHAKE, payload, &statusCode);
  // Further response handling...
\end{minted}


\subsection{Práce s Modemem a AT příkazy}
Komunikace s LTE modemem SIMCOM A7670 probíhá prostřednictvím sériové linky (UART) pomocí sady standardizovaných AT příkazů. 
Firmware využívá knihovnu \textbf{TinyGSM}, která umožňuje využití vysokoúrovňových metod (např. \texttt{gprsConnect}, \texttt{https\_post}) místo čistých AT příkazů.

Přesto je v některých případech nutné používat AT příkazy přímo, například při inicializaci modemu. 
Následující ukázka z funkce \texttt{modem\_initialize} ukazuje sekvenci AT příkazů pro ověření dostupnosti modemu a jeho zapnutí.


\begin{minted}{cpp}
bool modem_initialize() {
    // initialization sequence ...
  SerialAT.begin(115200, SERIAL_8N1, MODEM_RX_PIN, MODEM_TX_PIN);delay(100);
  if (g_modem.testAT(500)) {
      DBG_PRINTLN(F("[MODEM] Modem responded to AT"));modemReady = true;
  } else {
      DBG_PRINTLN(F("[MODEM] No response"));modemReady = false;
  }}
\end{minted}


Knihovna TinyGSM následně volání funkcí překládá na konkrétní AT příkazy. Například volání \texttt{g\_modem.getSignalQuality()} odešle příkaz \texttt{AT+CSQ} a vyparsuje odpověď ve formátu \texttt{+CSQ: <rssi>,<ber>}.


\subsection{OTA režim a konfigurační rozhraní}
\label{sec:hw_ota_mode}

Pro prvotní registraci, přenastavení konfigurace nebo nahrání nového firmwaru (v BIN formě), zařízení disponuje režimem "OTA" (Over-The-Air). Tento režim se aktivuje dlouhým stiskem ovládacího tlačítka při startu zařízení (cca 2 sekundy).

Detekce tohoto stavu probíhá v nejranější fázi funkce \texttt{setup()}, ještě před inicializací ostatních periferií. Pokud je detekován dlouhý stisk, zařízení nespustí standardní pracovní cyklus, ale přejde do smyčky OTA režimu.

V OTA režimu se ESP32 přepne do role Wi-Fi přístupového bodu (Access Pointu) s názvem \texttt{lotrTrackerOTA\_<DeviceID> (získano z MAC adresy)} a spustí webový server na adrese \texttt{192.168.4.1}. Uživatel se může připojit na tuto wifi síť a přes webové rozhraní provádět změny.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{../docs_hw/screenshots/apnwifi.png} 
    \caption{Ukázka Wi-Fi}
    \label{fig:wifi_apn_phone}
\end{figure}

Webové rozhraní nabízí následující funkce:
\begin{itemize}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item \textbf{Registration:} Spárování nového zařízení s uživatelským účtem.
    \item \textbf{Settings:} Konfigurace APN, adresy serveru a portu.
    \item \textbf{Test GPRS \& Test Serverové konektivity:} Okamžité ověření konektivity modemu a dostupnost serveru.
    \item \textbf{Firmware Update:} Nahrání nové binární verze firmware přímo z prohlížeče. (s následným restartem zařízení)
    \item \textbf{Clear Cache:} Pokud je potřeba, umožňuje vymazat uložená data v paměti.(např. pokud jsou data poškozena či ve špatném formátu a nelze je odeslat). používá funkce LittleFS.
\end{itemize}

\begin{minted}{cpp}
  // 2. Start WiFi AP
  DBG_PRINTLN(F("Starting WiFi AP..."));
  WiFi.disconnect(true);
  WiFi.mode(WIFI_AP);
  bool apStarted = ota_password.length() == 0 ? WiFi.softAP(ota_ssid.c_str())
            : WiFi.softAP(ota_ssid.c_str(), ota_password.c_str());
  if (apStarted) {
      DBG_PRINTLN(F("WiFi AP started with configured credentials."));}
  IPAddress apIP = WiFi.softAPIP();
  DBG_PRINT(F("AP IP address: ")); DBG_PRINTLN(apIP);
\end{minted}


\subsection{Uložení konfigurace zařízení}
Konfigurace, ať již nastavena v \texttt{/settings} (OTA režim) nebo samotné nastavení posílané Serverem, je trvale uložena v paměti pomocí knihovny \texttt{Preferences}. Mezi klíčové parametry patří:
\begin{itemize}
  \setlength\itemsep{0.2em}
  \setlength\parskip{0pt}
  \setlength\parsep{0pt}
    \item \texttt{apn}, \texttt{gprsUser}, \texttt{gprsPass}: Nastavení mobilní sítě.
    \item \texttt{server}, \texttt{port}: Cílová adresa backendu.
    \item \texttt{sleepTimeSeconds}: Interval mezi probuzeními.
    \item \texttt{minSatellitesForFix}: Minimální počet satelitů pro validní fix.
    \item \texttt{etc...}
\end{itemize}

\section{Obrázky}

%\begin{figure}[h]
%    \centering
%    \includegraphics[width=0.8\linewidth]{../docs_hw/screenshots/OTA_log_1.png}
%    \caption{log z OTA režimu}
%    \label{fig:ota_log}
%\end{figure}

\begin{figure}[h]
  \centering
  \begin{subfigure}{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{../docs_hw/screenshots/OTA1.png}
    \caption{registrace}
    \label{fig:ota_Registration}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.48\linewidth}
    \centering
    \includegraphics[width=\linewidth]{../docs_hw/screenshots/OTA3.png.jpg}
    \caption{OTA režim - webové rozhraní}
  \end{subfigure}
  \caption{OTA režim - webové rozhraní}
  \label{fig:ota_Settings}
\end{figure}


%\begin{figure}[h]
%   \centering
%   \includegraphics[width=1\linewidth]{../docs_hw/schemas/process_flow.png} 
%   \caption{Stavový diagram trackeru}
%   \label{fig:process_flow_tracker}
%\end{figure}

\cleardoublepage
